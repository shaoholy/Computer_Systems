        -:    0:Source:homework.c
        -:    0:Graph:homework.gcno
        -:    0:Data:homework.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/*
        -:    2: * file:        homework.c
        -:    3: * description: skeleton file for CS 5600/7600 file system
        -:    4: *
        -:    5: * CS 5600, Computer Systems, Northeastern CCIS
        -:    6: * Peter Desnoyers, November 2016
        -:    7: */
        -:    8:
        -:    9:#define FUSE_USE_VERSION 27
        -:   10:#define _GNU_SOURCE
        -:   11:
        -:   12:#include <libgen.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <stddef.h>
        -:   15:#include <unistd.h>
        -:   16:#include <fuse.h>
        -:   17:#include <fcntl.h>
        -:   18:#include <string.h>
        -:   19:#include <stdio.h>
        -:   20:#include <errno.h>
        -:   21:#include <math.h>
        -:   22:
        -:   23:#include "fsx600.h"
        -:   24:#include "blkdev.h"
        -:   25:
        -:   26:
        -:   27:extern int homework_part;       /* set by '-part n' command-line option */
        -:   28:
        -:   29:/*
        -:   30: * disk access - the global variable 'disk' points to a blkdev
        -:   31: * structure which has been initialized to access the image file.
        -:   32: *
        -:   33: * NOTE - blkdev access is in terms of 1024-byte blocks
        -:   34: */
        -:   35:extern struct blkdev *disk;
        -:   36:
        -:   37:/* by defining bitmaps as 'fd_set' pointers, you can use existing
        -:   38: * macros to handle them.
        -:   39: *   FD_ISSET(##, inode_map);
        -:   40: *   FD_CLR(##, block_map);
        -:   41: *   FD_SET(##, block_map);
        -:   42: */
        -:   43:fd_set *inode_map;              /* = malloc(sb.inode_map_size * FS_BLOCK_SIZE); */
        -:   44:fd_set *block_map;
        -:   45:struct fs_super super_blk;
        -:   46:struct fs_inode *inodes;
        -:   47:
        -:   48:/* init - this is called once by the FUSE framework at startup. Ignore
        -:   49: * the 'conn' argument.
        -:   50: * recommended actions:
        -:   51: *   - read superblock
        -:   52: *   - allocate memory, read bitmaps and inodes
        -:   53: */
        8:   54:void* fs_init(struct fuse_conn_info *conn)
        -:   55:{
        -:   56:
        8:   57:    if (disk->ops->read(disk, 0, 1, &super_blk) < 0)
    #####:   58:        exit(1);
        -:   59:
        -:   60:    /* your code here */
        -:   61:
        8:   62:    inode_map = (fd_set*) malloc(super_blk.inode_map_sz * FS_BLOCK_SIZE);
        8:   63:    block_map = (fd_set*) malloc(super_blk.block_map_sz * FS_BLOCK_SIZE);
        8:   64:    inodes = (struct fs_inode*) malloc(super_blk.inode_region_sz * FS_BLOCK_SIZE);
        -:   65:
        -:   66:    // inode_map = (void*)disk + FS_BLOCK_SIZE;
        -:   67:    // block_map = (void*)inode_map + sb.inode_map_sz * FS_BLOCK_SIZE;
        -:   68:    // inodes = (void*)block_map + sb.block_map_sz * FS_BLOCK_SIZE;
        -:   69:
        -:   70:    // read inode_map
        8:   71:    if (disk->ops->read(disk, 1, super_blk.inode_map_sz, inode_map) < 0) {
    #####:   72:        exit(1);
        -:   73:    }
        -:   74:
        -:   75:    // read block_map
        8:   76:    if (disk->ops->read(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map) < 0) {
    #####:   77:        exit(1);
        -:   78:    }
        -:   79:
        -:   80:    // read inodes
        8:   81:    if (disk->ops->read(disk, 1 + super_blk.inode_map_sz + super_blk.block_map_sz, super_blk.inode_region_sz, inodes) < 0) {
    #####:   82:        exit(1);
        -:   83:    }
        -:   84:
        8:   85:    return NULL;
        -:   86:}
        -:   87:
    14002:   88:static void writeEverythingtoDisk()
        -:   89:{
        -:   90:    // write inode_map
    14002:   91:    if (disk->ops->write(disk, 1, super_blk.inode_map_sz, inode_map) < 0) {
    #####:   92:        exit(1);
        -:   93:    }
        -:   94:
        -:   95:    // write block_map
    14002:   96:    if (disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map) < 0) {
    #####:   97:        exit(1);
        -:   98:    }
        -:   99:
        -:  100:    // write inodes
    14002:  101:    if (disk->ops->write(disk, 1 + super_blk.inode_map_sz + super_blk.block_map_sz, super_blk.inode_region_sz, inodes) < 0) {
    #####:  102:        exit(1);
        -:  103:    }
    14002:  104:}
        -:  105:
        -:  106:// Translate Function
        -:  107:
        -:  108:const char *delim = "/";
        -:  109:
    14556:  110:static int translate(const char *_path)
        -:  111:{
    14556:  112:    int inum = 1; // root inode
        -:  113:    int k, j;
    14556:  114:    int length = 0;
        -:  115:    const char *token[64];
    14556:  116:    char *p = NULL;
        -:  117:
    14556:  118:    if (strcmp(_path, "/") == 0) {
      213:  119:        return inum;
        -:  120:    }
        -:  121:
    14343:  122:    char *path = strdupa(_path);
    14343:  123:    p = strtok(path, delim);
        -:  124:
    48517:  125:    while (p) {
    19831:  126:        token[length++] = p;
    19831:  127:        p = strtok(0, delim);
        -:  128:    }
    14343:  129:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
        -:  130:
    34159:  131:    for(j = 0; j < length; j++) {
    19831:  132:        bzero(de, FS_BLOCK_SIZE);
    19831:  133:        if (!S_ISDIR(inodes[inum].mode)) return -ENOTDIR;
    19816:  134:        if (disk->ops->read(disk, inodes[inum].direct[0], 1, de) < 0) {
    #####:  135:            exit(1);
        -:  136:        }
   103921:  137:        for (k = 0; k <= 31; k++) {
   103921:  138:            if (de[k].valid && (strcmp(de[k].name, token[j]) == 0)) {
    19353:  139:                inum = de[k].inode;
    19353:  140:                break;
        -:  141:            }
    84568:  142:            if (k == 31) {
      463:  143:                inum = -ENOENT;
      463:  144:                break;
        -:  145:            }
        -:  146:        }
        -:  147:    }
    14328:  148:    free(de);
    14328:  149:    return inum;
        -:  150:}
        -:  151:
        -:  152:/* Note on path translation errors:
        -:  153: * In addition to the method-specific errors listed below, almost
        -:  154: * every method can return one of the following errors if it fails to
        -:  155: * locate a file or directory corresponding to a specified path.
        -:  156: *
        -:  157: * ENOENT - a component of the path is not present.
        -:  158: * ENOTDIR - an intermediate component of the path (e.g. 'b' in
        -:  159: *           /a/b/c) is not a directory
        -:  160: */
        -:  161:
        -:  162:/* note on splitting the 'path' variable:
        -:  163: * the value passed in by the FUSE framework is declared as 'const',
        -:  164: * which means you can't modify it. The standard mechanisms for
        -:  165: * splitting strings in C (strtok, strsep) modify the string in place,
        -:  166: * so you have to copy the string and then free the copy when you're
        -:  167: * done. One way of doing this:
        -:  168: *
        -:  169: *    char *_path = strdup(path);
        -:  170: *    int inum = translate(_path);
        -:  171: *    free(_path);
        -:  172: */
        -:  173:
        -:  174:/* getattr - get file or directory attributes. For a description of
        -:  175: *  the fields in 'struct stat', see 'man lstat'.
        -:  176: *
        -:  177: * Note - fields not provided in fsx600 are:
        -:  178: *    st_nlink - always set to 1
        -:  179: *    st_atime, st_ctime - set to same value as st_mtime
        -:  180: *
        -:  181: * errors - path translation, ENOENT
        -:  182: */
        -:  183:
      915:  184:static void fill_stat(int inum, struct fs_inode _inode ,struct stat *sb) {
        -:  185:
      915:  186:    memset(sb,0,sizeof(*sb));
      915:  187:    sb->st_dev = 0;                    /* ID of device containing file */
      915:  188:    sb->st_ino = inum;                /* inode number */
      915:  189:    sb->st_mode = _inode.mode;     /* protection */
      915:  190:    sb->st_nlink = 1;                  /* number of hard links */
      915:  191:    sb->st_uid = _inode.uid;       /* user ID of owner */
      915:  192:    sb->st_gid = _inode.gid;       /* group ID of owner */
      915:  193:    sb->st_rdev = 0;                   /* device ID (if special file) */
      915:  194:    sb->st_size = _inode.size;     /* total size, in bytes */
      915:  195:    sb->st_blksize = FS_BLOCK_SIZE;    /* blocksize for filesystem I/O */
      915:  196:    sb->st_blocks = (_inode.size + FS_BLOCK_SIZE - 1) / FS_BLOCK_SIZE;  /* number of 512B blocks allocated */
      915:  197:    sb->st_atime = _inode.mtime;   /* time of last access */
      915:  198:    sb->st_mtime = _inode.mtime;   /* time of last modification */
      915:  199:    sb->st_ctime = _inode.ctime;   /* time of last status change */
        -:  200:
      915:  201:}
        -:  202:
      433:  203:static int fs_getattr(const char *path, struct stat *sb)
        -:  204:{
      433:  205:    int inum = translate(path);
      433:  206:    if (inum < 0) {
      243:  207:        return inum;
        -:  208:    }
        -:  209:
      190:  210:    struct fs_inode _inode = inodes[inum];
      190:  211:    fill_stat(inum, _inode, sb);
        -:  212:
      190:  213:    return 0;
        -:  214:}
        -:  215:
        -:  216:/* readdir - get directory contents.
        -:  217: *
        -:  218: * for each entry in the directory, invoke the 'filler' function,
        -:  219: * which is passed as a function pointer, as follows:
        -:  220: *     filler(buf, <name>, <statbuf>, 0)
        -:  221: * where <statbuf> is a struct stat, just like in getattr.
        -:  222: *
        -:  223: * Errors - path resolution, ENOTDIR, ENOENT
        -:  224: */
      201:  225:static int fs_readdir(const char *path, void *ptr, fuse_fill_dir_t filler,
        -:  226:   off_t offset, struct fuse_file_info *fi)
        -:  227:{
      201:  228:    int i = 0;
        -:  229:    struct stat sb;
        -:  230:
      201:  231:    int inum = translate(path);
      201:  232:    if (inum < 0) {
        6:  233:        return inum;
        -:  234:    }
      195:  235:    if (!S_ISDIR(inodes[inum].mode)) return -ENOTDIR;
        -:  236:
        -:  237:    // struct fs_inode _inode = inodes[inum];
      193:  238:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
      193:  239:    if (disk->ops->read(disk, inodes[inum].direct[0], 1, de) < 0) {
    #####:  240:        exit(1);
        -:  241:    }
        -:  242:    // sb = (struct stat*) malloc(sizeof(struct stat));
        -:  243:
     6369:  244:    for (; i <=31; i++) {
     6176:  245:        if (!de[i].valid) {
     5451:  246:            continue;
        -:  247:        }
      725:  248:        fill_stat(inum, inodes[de[i].inode], &sb);
      725:  249:        filler(ptr, de[i].name, &sb, 0);
        -:  250:    }
      193:  251:    free(de);
      193:  252:    return 0;
        -:  253:}
        -:  254:
        -:  255:/* see description of Part 2. In particular, you can save information
        -:  256: * in fi->fh. If you allocate memory, free it in fs_releasedir.
        -:  257: */
      141:  258:static int fs_opendir(const char *path, struct fuse_file_info *fi)
        -:  259:{
      141:  260:    return 0;
        -:  261:}
        -:  262:
      141:  263:static int fs_releasedir(const char *path, struct fuse_file_info *fi)
        -:  264:{
      141:  265:    return 0;
        -:  266:}
        -:  267:
      150:  268:static int getFreeInodeIndex()
        -:  269:{
        -:  270:    int i;
     4473:  271:    for (i = 0; i < super_blk.inode_map_sz * FS_BLOCK_SIZE; i++) {
     4473:  272:        if (!FD_ISSET(i, inode_map)) {
      150:  273:            return i;
        -:  274:        }
        -:  275:    }
    #####:  276:    return -ENOSPC;
        -:  277:}
        -:  278:
     5565:  279:static int getFreeBlockIndex()
        -:  280:{
        -:  281:    int i;
  2966056:  282:    for (i = 0; i < super_blk.block_map_sz * FS_BLOCK_SIZE; i++) {
  2966054:  283:        if (!FD_ISSET(i, block_map)) {
     5563:  284:            return i;
        -:  285:        }
        -:  286:    }
        2:  287:    return -ENOSPC;
        -:  288:}
        -:  289:
      267:  290:static void resolvePath(const char*_path, char dname[], char base[])
        -:  291:{
      267:  292:    char * path = strdupa(_path);
        -:  293:
      267:  294:    char *last = strrchr(path, '/') + 1;
      267:  295:    strcpy(base, last);
        -:  296:    // *base = basename (path);
      267:  297:    strcpy(dname, dirname(path));   
        -:  298:    
        -:  299:
      267:  300:    return;
        -:  301:}
        -:  302:
      170:  303:static int addEntity(const char *path, mode_t mode, int isDir)
        -:  304:{
        -:  305:    // Resolve Path
        -:  306:    // i.e. split into directory one above last and last
        -:  307:    // /a/b/c  ->  /a/b (dirname)  & c (base)
        -:  308:    //
        -:  309:    // Translate path for both
        -:  310:    // check and return Error codes
        -:  311:    // if dirname doesnt exist
        -:  312:    // if base isn't a directory
        -:  313:    // Go through all directory entries for *dname* and check if *base* exists
        -:  314:    // Find invalid index in drectory that can be used
        -:  315:    // Modify directory entry for *base* with new values
        -:  316:    // and write to disk
        -:  317:    //
        -:  318:    int index;
        -:  319:    char base[1024];
        -:  320:    char dname[1024];
        -:  321:
      170:  322:    resolvePath(path, dname, base);
        -:  323:
      170:  324:    int inumDir = translate(dname);
      170:  325:    int inumBase = translate(base);
        -:  326:
      170:  327:    if (inumDir < 0) {
        2:  328:        return -ENOENT;
      168:  329:    } else if (!S_ISDIR(inodes[inumDir].mode)) {
        1:  330:        return -ENOTDIR;
        -:  331:    }
        -:  332:
      167:  333:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
      167:  334:    if (disk->ops->read(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  335:        exit(1);
        -:  336:    }
        -:  337:
     5123:  338:    for (index = 0; index <= 31; index++) {
     4969:  339:        if (de[index].valid) {
     1466:  340:            if (strcmp(de[index].name, base) == 0) {
       13:  341:                free(de);
       13:  342:                return -EEXIST;
        -:  343:            }
        -:  344:        } 
        -:  345:    }
        -:  346:
     1503:  347:    for (index = 0; index <= 31; index++) {
     1503:  348:        if (de[index].valid == 0) {
      150:  349:            break;
        -:  350:        }
     1353:  351:        if (index == 31) {
        4:  352:            free(de);
        4:  353:            return -ENOSPC;
        -:  354:        }
        -:  355:    }
        -:  356:
      150:  357:    int freeInodeIndex = getFreeInodeIndex();
      150:  358:    int freeBlockIndex = getFreeBlockIndex();
        -:  359:
      150:  360:    if (freeInodeIndex < 0 || freeBlockIndex < 0) {
        1:  361:        return -ENOSPC;
        -:  362:    }
        -:  363:
      149:  364:    FD_SET(freeInodeIndex, inode_map);
        -:  365:
      149:  366:    struct fs_inode *_inode = &inodes[freeInodeIndex];
      149:  367:    struct fuse_context *ctx = fuse_get_context();
        -:  368:
      149:  369:    _inode->uid = ctx->uid;
      149:  370:    _inode->gid = ctx->gid;
      149:  371:    _inode->mode =  mode;
      149:  372:    _inode->ctime = time(NULL);
      149:  373:    _inode->mtime = _inode->ctime;
      149:  374:    _inode->size = 0;
        -:  375:    
      149:  376:    if (isDir) {
       94:  377:        FD_SET(freeBlockIndex, block_map);
       94:  378:        _inode->direct[0] = freeBlockIndex; 
        -:  379:    }
        -:  380:
      149:  381:    de[index].valid = 1;
      149:  382:    de[index].isDir = isDir;
      149:  383:    de[index].inode = freeInodeIndex;
      149:  384:    strcpy(de[index].name, base);
        -:  385:
        -:  386:    // write directory
      149:  387:    if (disk->ops->write(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  388:        exit(1);
        -:  389:    }
        -:  390:
      149:  391:    writeEverythingtoDisk();
        -:  392:
      149:  393:    free(de);
        -:  394:
      149:  395:    return 0;
        -:  396:}
        -:  397:
        -:  398:/* mknod - create a new file with permissions (mode & 01777)
        -:  399: *
        -:  400: * Errors - path resolution, EEXIST
        -:  401: *          in particular, for mknod("/a/b/c") to succeed,
        -:  402: *          "/a/b" must exist, and "/a/b/c" must not.
        -:  403: *
        -:  404: * If a file or directory of this name already exists, return -EEXIST.
        -:  405: * If this would result in >32 entries in a directory, return -ENOSPC
        -:  406: * if !S_ISREG(mode) return -EINVAL [i.e. 'mode' specifies a device special
        -:  407: * file or other non-file object]
        -:  408: */
       67:  409:static int fs_mknod(const char *path, mode_t mode, dev_t dev)
        -:  410:{
       67:  411:    int isDir = 0;
       67:  412:    if (!S_ISREG(mode)) return -EINVAL;
       67:  413:    return addEntity(path, mode | S_IFREG , isDir);
        -:  414:    // return -EOPNOTSUPP;
        -:  415:}
        -:  416:
        -:  417:/* mkdir - create a directory with the given mode.
        -:  418: * Errors - path resolution, EEXIST
        -:  419: * Conditions for EEXIST are the same as for create.
        -:  420: * If this would result in >32 entries in a directory, return -ENOSPC
        -:  421: *
        -:  422: * Note that you may want to combine the logic of fs_mknod and
        -:  423: * fs_mkdir.
        -:  424: */
      103:  425:static int fs_mkdir(const char *path, mode_t mode)
        -:  426:{
      103:  427:    int isDir = 1;
      103:  428:    return addEntity(path, mode | S_IFDIR , isDir);
        -:  429:    // return -EOPNOTSUPP;
        -:  430:}
        -:  431:
       41:  432:static struct fs_inode removeAllData(struct fs_inode _inode)
        -:  433:{
        -:  434:    int dir;
        -:  435:    int k;
        -:  436:    int i;
        -:  437:    int *indirect1;
        -:  438:    int *indirect2;
        -:  439:    int *double_indirect2;
        -:  440:    int *block;
        -:  441:
      287:  442:    for(dir = 0; dir<6; dir++) {
      246:  443:        if (_inode.direct[dir]) {
      169:  444:            block = malloc(FS_BLOCK_SIZE);
      169:  445:            if (disk->ops->read(disk, _inode.direct[dir], 1, block) < 0) {
    #####:  446:                exit(1);
        -:  447:            }
      169:  448:            memset(block, 0, FS_BLOCK_SIZE);
      169:  449:            if (disk->ops->write(disk, _inode.direct[dir], 1, block) < 0) {
    #####:  450:                exit(1);
        -:  451:            }
      169:  452:            FD_CLR(_inode.direct[dir], block_map);
      169:  453:            _inode.direct[dir] = 0;
      169:  454:            free(block);
        -:  455:        }
        -:  456:    }
       41:  457:    if (_inode.indir_1) {
       26:  458:        indirect1 = malloc(sizeof(int) * 256);
       26:  459:        if (disk->ops->read(disk, _inode.indir_1, 1, indirect1) < 0) {
    #####:  460:            exit(1);
        -:  461:        }
     6682:  462:        for (k = 0; k < 256; k++) {
     6656:  463:            if (indirect1[k] && FD_ISSET(indirect1[k], block_map)) {
        -:  464:
     3776:  465:                block = malloc(FS_BLOCK_SIZE);
     3776:  466:                if (disk->ops->read(disk, indirect1[k], 1, block) < 0) {
    #####:  467:                    exit(1);
        -:  468:                }
     3776:  469:                memset(block, 0, FS_BLOCK_SIZE);
     3776:  470:                if (disk->ops->write(disk, indirect1[k], 1, block) < 0) {
    #####:  471:                    exit(1);
        -:  472:                }
        -:  473:
     3776:  474:                FD_CLR(indirect1[k], block_map);
     3776:  475:                indirect1[k] = 0;
     3776:  476:                free(block);
        -:  477:            }
        -:  478:        }
       26:  479:        if (disk->ops->write(disk, _inode.indir_1, 1, indirect1) < 0) {
    #####:  480:            exit(1);
        -:  481:        }
        -:  482:
       26:  483:        FD_CLR(_inode.indir_1, block_map);
       26:  484:        _inode.indir_1 = 0;
       26:  485:        free(indirect1);
        -:  486:    }
        -:  487:
       41:  488:    if (_inode.indir_2) {
        6:  489:        indirect2 = malloc(sizeof(int) * 256);
        6:  490:        if (disk->ops->read(disk, _inode.indir_2, 1, indirect2) < 0) {
    #####:  491:            exit(1);
        -:  492:        }
     1542:  493:        for (k = 0; k < 256; k++) {
     1536:  494:            if (indirect2[k]) {
        6:  495:                double_indirect2 = malloc(sizeof(int) * 256);
        6:  496:                if (disk->ops->read(disk, indirect2[k], 1, double_indirect2) < 0) {
    #####:  497:                    exit(1);
        -:  498:                }
     1542:  499:                for (i = 0; i < 256; i++) {
     1536:  500:                    if (double_indirect2[i] && FD_ISSET(double_indirect2[i], block_map)) {
        -:  501:
      473:  502:                        block = malloc(FS_BLOCK_SIZE);
      473:  503:                        if (disk->ops->read(disk, double_indirect2[i], 1, block) < 0) {
    #####:  504:                            exit(1);
        -:  505:                        }
      473:  506:                        memset(block, 0, FS_BLOCK_SIZE);
      473:  507:                        if (disk->ops->write(disk, double_indirect2[i], 1, block) < 0) {
    #####:  508:                            exit(1);
        -:  509:                        }
        -:  510:
      473:  511:                        FD_CLR(double_indirect2[i], block_map);
      473:  512:                        double_indirect2[i] = 0;
      473:  513:                        free(block);
        -:  514:                    }
        -:  515:                }
        6:  516:                if (disk->ops->write(disk, indirect2[k], 1, double_indirect2) < 0) {
    #####:  517:                    exit(1);
        -:  518:                }
        6:  519:                FD_CLR(indirect2[k], block_map);
        6:  520:                indirect2[k] = 0;
        6:  521:                free(double_indirect2);
        -:  522:            }
        -:  523:        }
        6:  524:        if (disk->ops->write(disk, _inode.indir_2, 1, indirect2) < 0) {
    #####:  525:            exit(1);
        -:  526:        }
        -:  527:
        6:  528:        FD_CLR(_inode.indir_2, block_map);
        6:  529:        _inode.indir_2 = 0;
        6:  530:        free(indirect2);
        -:  531:    }
        -:  532:
       41:  533:    return _inode;
        -:  534:}
        -:  535:
        -:  536:/* truncate - truncate file to exactly 'len' bytes
        -:  537: * Errors - path resolution, ENOENT, EISDIR, EINVAL
        -:  538: *    return EINVAL if len > 0.
        -:  539: */
       21:  540:static int fs_truncate(const char *path, off_t len)
        -:  541:{
        -:  542:    /* you can cheat by only implementing this for the case of len==0,
        -:  543:     * and an error otherwise.
        -:  544:     */
       21:  545:    if (len != 0) return -EINVAL;		/* invalid argument */
        -:  546:
        -:  547:    int index;
        -:  548:    char base[1024];
        -:  549:    char dname[1024];
        -:  550:
       21:  551:    resolvePath(path, dname, base);
       21:  552:    int inum = translate(path);
       21:  553:    int inumDir = translate(dname);
        -:  554:
       21:  555:    if (inum < 0) {
        3:  556:        return -ENOENT;
       18:  557:    } else if (S_ISDIR(inodes[inum].mode)) {
        2:  558:        return -EISDIR;
        -:  559:    }
        -:  560:
       16:  561:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
       16:  562:    if (disk->ops->read(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  563:        exit(1);
        -:  564:    }
        -:  565:
       75:  566:    for (index = 0; index<=31; index++) {
       75:  567:        if(de[index].valid && strcmp(de[index].name, base) == 0) {
        -:  568:
        -:  569:            // trucate
       16:  570:            inodes[de[index].inode].size = 0;
       16:  571:            inodes[de[index].inode].mtime = time(NULL);
        -:  572:
       16:  573:            struct fs_inode _inode = inodes[de[index].inode];
       16:  574:            inodes[de[index].inode] = removeAllData(_inode);
       16:  575:            break;
        -:  576:        }
        -:  577:    }
        -:  578:
       16:  579:    inodes[inumDir].mtime = time(NULL);
        -:  580:
        -:  581:    // write directory
       16:  582:    if (disk->ops->write(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  583:        exit(1);
        -:  584:    }
        -:  585:
       16:  586:    writeEverythingtoDisk();
        -:  587:
       16:  588:    free(de);
       16:  589:    return 0;
        -:  590:    // return -EOPNOTSUPP;
        -:  591:}
        -:  592:
        -:  593:/* unlink - delete a file
        -:  594: *  Errors - path resolution, ENOENT, EISDIR
        -:  595: * Note that you have to delete (i.e. truncate) all the data.
        -:  596: */
       35:  597:static int fs_unlink(const char *path)
        -:  598:{
        -:  599:    int index;
        -:  600:    int dir;
        -:  601:    char base[1024];
        -:  602:    char dname[1024];
        -:  603:
       35:  604:    resolvePath(path, dname, base);
       35:  605:    int inum = translate(path);
       35:  606:    int inumDir = translate(dname);
        -:  607:
       35:  608:    if (inum < 0) {
        8:  609:        return -ENOENT;
       27:  610:    } else if (S_ISDIR(inodes[inum].mode)) {
        2:  611:        return -EISDIR;
        -:  612:    }
        -:  613:
       25:  614:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
       25:  615:    if (disk->ops->read(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  616:        exit(1);
        -:  617:    }
        -:  618:
      124:  619:    for (index = 0; index<=31; index++) {
      124:  620:        if(de[index].valid && strcmp(de[index].name, base) == 0) {
        -:  621:
        -:  622:            // unlink
       25:  623:            de[index].valid = 0;
       25:  624:            FD_CLR(de[index].inode, inode_map);
        -:  625:
       25:  626:            struct fs_inode _inode = inodes[de[index].inode];
       25:  627:            inodes[de[index].inode] = removeAllData(_inode);
       25:  628:            break;
        -:  629:        }
        -:  630:    }
        -:  631:
       25:  632:    inodes[inumDir].mtime = time(NULL);
        -:  633:
        -:  634:    // write directory
       25:  635:    if (disk->ops->write(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  636:        exit(1);
        -:  637:    }
        -:  638:
       25:  639:    writeEverythingtoDisk();
        -:  640:
       25:  641:    free(de);
       25:  642:    return 0;
        -:  643:    // return -EOPNOTSUPP;
        -:  644:}
        -:  645:
        4:  646:static int isDirEmpty(int inum)
        -:  647:{
        -:  648:    int index;
        4:  649:    int result = 1;
        4:  650:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
        4:  651:    if (disk->ops->read(disk, inodes[inum].direct[0], 1, de) < 0) {
    #####:  652:        exit(1);
        -:  653:    }
        -:  654:
      132:  655:    for (index = 0; index <= 31; index++) {
      128:  656:        if (de[index].valid) {
        2:  657:            result = 0;
        -:  658:        } 
        -:  659:    }
        4:  660:    free(de);
        4:  661:    return result;
        -:  662:}
        -:  663:
        -:  664:/* rmdir - remove a directory
        -:  665: *  Errors - path resolution, ENOENT, ENOTDIR, ENOTEMPTY
        -:  666: */
        9:  667:static int fs_rmdir(const char *path)
        -:  668:{
        -:  669:    int index;
        -:  670:    char base[1024];
        -:  671:    char dname[1024];
        -:  672:
        9:  673:    int inum = translate(path);
        9:  674:    resolvePath(path, dname, base);
        9:  675:    int inumDir = translate(dname);
        -:  676:
        9:  677:    if (inum < 0) {
        4:  678:        return -ENOENT;
        5:  679:    } else if (!S_ISDIR(inodes[inum].mode)) {
        1:  680:        return -ENOTDIR;
        4:  681:    } else if (!isDirEmpty(inum)) {
        2:  682:        return -ENOTEMPTY;
        -:  683:    }
        -:  684:
        2:  685:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
        2:  686:    if (disk->ops->read(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  687:        exit(1);
        -:  688:    }
        -:  689:
        2:  690:    for (index = 0; index <= 31; index++) {
        2:  691:        if (de[index].valid && (strcmp(de[index].name, base) == 0)) {
        2:  692:            de[index].valid = 0;
        2:  693:            FD_CLR(de[index].inode, inode_map);
        2:  694:            break;
        -:  695:        } 
        -:  696:    }
        -:  697:    
        2:  698:    inodes[inumDir].mtime = time(NULL);
        2:  699:    FD_CLR(inodes[inum].direct[0], block_map);
        -:  700:
        -:  701:    // write directory
        2:  702:    if (disk->ops->write(disk, inodes[inumDir].direct[0], 1, de) < 0) {
    #####:  703:        exit(1);
        -:  704:    }
        -:  705:
        2:  706:    writeEverythingtoDisk();
        -:  707:
        2:  708:    free(de);
        2:  709:    return 0;
        -:  710:    // return -EOPNOTSUPP;
        -:  711:}
        -:  712:
        -:  713:/* rename - rename a file or directory
        -:  714: * Errors - path resolution, ENOENT, EINVAL, EEXIST
        -:  715: *
        -:  716: * ENOENT - source does not exist
        -:  717: * EEXIST - destination already exists
        -:  718: * EINVAL - source and destination are not in the same directory
        -:  719: *
        -:  720: * Note that this is a simplified version of the UNIX rename
        -:  721: * functionality - see 'man 2 rename' for full semantics. In
        -:  722: * particular, the full version can move across directories, replace a
        -:  723: * destination file, and replace an empty directory with a full one.
        -:  724: */
       37:  725:static int fs_rename(const char *src_path, const char *dst_path)
        -:  726:{
        -:  727:    int index;
        -:  728:    char direct_dst[1024];
        -:  729:    char direct_src[1024];
        -:  730:    char base_dst[1024];
        -:  731:    char base_src[1024];
        -:  732:
       37:  733:    int inumSrc = translate(src_path);
       37:  734:    int inumDst = translate(dst_path);
        -:  735:
       37:  736:    if (inumSrc < 0) {
       11:  737:        return -ENOENT;
        -:  738:    }
       26:  739:    if (inumDst >= 0) {
       10:  740:        return -EEXIST;
        -:  741:    }
        -:  742:
       16:  743:    resolvePath(src_path, direct_src, base_src);
       16:  744:    resolvePath(dst_path, direct_dst, base_dst);
        -:  745:
       16:  746:    if (strcmp(direct_src, direct_dst) != 0) {
        6:  747:        return -EINVAL;
        -:  748:    }
        -:  749:
       10:  750:    int parentSrc = translate(direct_src);
       10:  751:    struct fs_dirent *de =  (struct fs_dirent*) malloc(FS_BLOCK_SIZE);
       10:  752:    if (disk->ops->read(disk, inodes[parentSrc].direct[0], 1, de) < 0) {
    #####:  753:        exit(1);
        -:  754:    }
        -:  755:
       38:  756:    for (index = 0; index <= 31; index++) {
       38:  757:        if (de[index].valid) {
       30:  758:            if (strcmp(de[index].name, base_src) == 0) {
       10:  759:                strcpy(de[index].name, base_dst);
       10:  760:                break;
        -:  761:            }
        -:  762:        } 
        -:  763:    }
        -:  764:
       10:  765:    inodes[inumSrc].mtime = time(NULL);
        -:  766:
        -:  767:    // write directory
       10:  768:    if (disk->ops->write(disk, inodes[parentSrc].direct[0], 1, de) < 0) {
    #####:  769:        exit(1);
        -:  770:    }
        -:  771:
        -:  772:    // write inodes
       10:  773:    if (disk->ops->write(disk, 1 + super_blk.inode_map_sz + super_blk.block_map_sz, super_blk.inode_region_sz, inodes) < 0) {
    #####:  774:        exit(1);
        -:  775:    }
        -:  776:
       10:  777:    free(de);
        -:  778:
       10:  779:    return 0;
        -:  780:
        -:  781:    // return -EOPNOTSUPP;
        -:  782:}
        -:  783:
        -:  784:/* chmod - change file permissions
        -:  785: * utime - change access and modification times
        -:  786: *         (for definition of 'struct utimebuf', see 'man utime')
        -:  787: *
        -:  788: * Errors - path resolution, ENOENT.
        -:  789: */
        9:  790:static int fs_chmod(const char *path, mode_t mode)
        -:  791:{
        9:  792:    int inum = translate(path);
        -:  793:
        9:  794:    if (inum < 0) {
        1:  795:        return inum;
        -:  796:    }
        -:  797:
        8:  798:    inodes[inum].mode = S_ISDIR(mode) ? (mode | S_IFDIR) :  (mode | S_IFREG);
        -:  799:
        8:  800:    if (disk->ops->write(disk, 1 + super_blk.inode_map_sz + super_blk.block_map_sz, super_blk.inode_region_sz, inodes) < 0) {
    #####:  801:        exit(1);
        -:  802:    }
        -:  803:
        8:  804:    return 0;
        -:  805:}
        -:  806:
        4:  807:int fs_utime(const char *path, struct utimbuf *ut)
        -:  808:{
        4:  809:    int inum = translate(path);
        -:  810:
        4:  811:    if (inum < 0) {
        1:  812:        return inum;
        -:  813:    }
        -:  814:
        3:  815:    inodes[inum].mtime = ut->modtime;
        -:  816:
        3:  817:    if (disk->ops->write(disk, 1 + super_blk.inode_map_sz + super_blk.block_map_sz, super_blk.inode_region_sz, inodes) < 0) {
    #####:  818:        exit(1);
        -:  819:    }
        -:  820:
        3:  821:    return 0;
        -:  822:}
        -:  823:
        -:  824:
        -:  825:// static int logical2Physical(struct fs_inode _inode, int n, int allo)
        -:  826:// {
        -:  827://     int result;
        -:  828://     if (n < 6) {
        -:  829://         result = _inode.direct[n];
        -:  830://         return result;
        -:  831://     }
        -:  832://     n -= 6;
        -:  833://     if (n < 256) {   
        -:  834://         int *indirect1 = malloc(sizeof(int) * 256);
        -:  835://         if (disk->ops->read(disk, _inode.indir_1, 1, indirect1) < 0) {
        -:  836://             exit(1);
        -:  837://         }
        -:  838://         result = indirect1[n];
        -:  839://         free(indirect1);
        -:  840://         return result;
        -:  841://     }
        -:  842:
        -:  843://     n -= 256;
        -:  844://     int *indirect2 = malloc(sizeof(int) * 256);
        -:  845://     if (disk->ops->read(disk, _inode.indir_2, 1, indirect2) < 0) {
        -:  846://         exit(1);
        -:  847://     }
        -:  848://     int *double_indirect2 = malloc(sizeof(int) * 256);
        -:  849://     if (disk->ops->read(disk, indirect2[n/256], 1, double_indirect2) < 0) {
        -:  850://         exit(1);
        -:  851://     }
        -:  852://     result = double_indirect2[n%256];
        -:  853://     free(double_indirect2);
        -:  854://     free(indirect2);
        -:  855://     return result;
        -:  856:    
        -:  857:// }
        -:  858:// 
        -:  859:
    19312:  860:static int logical2Physical(int inum, int n, int allo)
        -:  861:{
    19312:  862:    int result = 0;
        -:  863:    int i;
        -:  864:
    19312:  865:    struct fs_inode _inode = inodes[inum];
    19312:  866:    if (n < 6) {
        -:  867:
     8852:  868:        result = _inode.direct[n];
     8852:  869:        if (allo && !result) {
      266:  870:            result = getFreeBlockIndex();
      266:  871:            if (result < 0) return -ENOSPC;
      266:  872:            _inode.direct[n] = result;
      266:  873:            FD_SET(result, block_map);
      266:  874:            disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map);
        -:  875:        }
     8852:  876:        inodes[inum] = _inode;
     8852:  877:        return result;
        -:  878:    }
        -:  879:
    10460:  880:    n -= 6;
        -:  881:
    10460:  882:    if (n < 256) {   
        -:  883:
     9466:  884:        if (!allo) {
     2186:  885:            int *indirect1 = malloc(sizeof(int) * 256);
     2186:  886:            if (disk->ops->read(disk, _inode.indir_1, 1, indirect1) < 0) {
    #####:  887:                exit(1);
        -:  888:            }
     2186:  889:            result = indirect1[n];
     2186:  890:            free(indirect1);
        -:  891:        } else {
     7280:  892:            if (!_inode.indir_1) {
       42:  893:                int index = getFreeBlockIndex();
       42:  894:                if (result < 0) return -ENOSPC;
       42:  895:                _inode.indir_1 = index;
       42:  896:                FD_SET(index, block_map);
       42:  897:                disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map);
        -:  898:
        -:  899:            }
        -:  900:
     7280:  901:            int *indirect1 = malloc(sizeof(int) * 256);
     7280:  902:            if (disk->ops->read(disk, _inode.indir_1, 1, indirect1) < 0) {
    #####:  903:                exit(1);
        -:  904:            }
        -:  905:
     7280:  906:            result = indirect1[n];
     7280:  907:            if (!result) {
     4527:  908:                result = getFreeBlockIndex();
     4527:  909:                if (result < 0) return -ENOSPC;
     4526:  910:                indirect1[n] = result;
     4526:  911:                FD_SET(result, block_map);
     4526:  912:                disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map);
        -:  913:            }
        -:  914:
     7279:  915:            if (disk->ops->write(disk, _inode.indir_1, 1, indirect1) < 0) {
    #####:  916:                exit(1);
        -:  917:            }
     7279:  918:            free(indirect1);
        -:  919:        }
     9465:  920:        inodes[inum] = _inode;
     9465:  921:        return result;
        -:  922:    }
        -:  923:
      994:  924:    n -= 256;
        -:  925:
      994:  926:    if (!allo) {
       48:  927:        int *indirect2 = malloc(sizeof(int) * 256);
       48:  928:        if (disk->ops->read(disk, _inode.indir_2, 1, indirect2) < 0) {
    #####:  929:            exit(1);
        -:  930:        }
       48:  931:        int *double_indirect2 = malloc(sizeof(int) * 256);
       48:  932:        if (disk->ops->read(disk, indirect2[n/256], 1, double_indirect2) < 0) {
    #####:  933:            exit(1);
        -:  934:        }
        -:  935:
       48:  936:        result = double_indirect2[n%256];
       48:  937:        free(double_indirect2);
       48:  938:        free(indirect2);
       48:  939:        return result;
        -:  940:
        -:  941:    } else {
      946:  942:        if (!_inode.indir_2) {
        7:  943:            int index = getFreeBlockIndex();
        7:  944:            if (result < 0) return -ENOSPC;
        7:  945:            _inode.indir_2 = index;
        7:  946:            FD_SET(index, block_map);
        7:  947:            disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map);
        -:  948:        }
      946:  949:        int *indirect2 = malloc(sizeof(int) * 256);
      946:  950:        if (disk->ops->read(disk, _inode.indir_2, 1, indirect2) < 0) {
    #####:  951:            exit(1);
        -:  952:        }
        -:  953:
      946:  954:        if (!indirect2[n/256]) {
        7:  955:            int index = getFreeBlockIndex();
        7:  956:            if (result < 0) return -ENOSPC;
        7:  957:            indirect2[n/256] = index;
        7:  958:            FD_SET(index, block_map);
        7:  959:            disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map);
        -:  960:        }
        -:  961:
      946:  962:        if (disk->ops->write(disk, _inode.indir_2, 1, indirect2) < 0) {
    #####:  963:            exit(1);
        -:  964:        }
        -:  965:
      946:  966:        int *double_indirect2 = malloc(sizeof(int) * 256);
      946:  967:        if (disk->ops->read(disk, indirect2[n/256], 1, double_indirect2) < 0) {
    #####:  968:            exit(1);
        -:  969:        }
        -:  970:
      946:  971:        result = double_indirect2[n%256];
      946:  972:        if (!result) {
      566:  973:            result = getFreeBlockIndex();
      566:  974:            if (result < 0) return -ENOSPC;
      566:  975:            double_indirect2[n%256] = result;
      566:  976:            FD_SET(result, block_map);
      566:  977:            disk->ops->write(disk, 1 + super_blk.inode_map_sz, super_blk.block_map_sz, block_map);
        -:  978:        }
        -:  979:
      946:  980:        if (disk->ops->write(disk, indirect2[n/256], 1, double_indirect2) < 0) {
    #####:  981:            exit(1);
        -:  982:        }
        -:  983:
      946:  984:        inodes[inum] = _inode;
      946:  985:        free(double_indirect2);
      946:  986:        free(indirect2);
      946:  987:        return result;
        -:  988:    }
        -:  989:}
        -:  990:/* read - read data from an open file.
        -:  991: * should return exactly the number of bytes requested, except:
        -:  992: *   - if offset >= file len, return 0
        -:  993: *   - if offset+len > file len, return bytes from offset to EOF
        -:  994: *   - on error, return <0
        -:  995: * Errors - path resolution, ENOENT, EISDIR
        -:  996: */
        -:  997:
        -:  998:/**
        -:  999:     * Depending on offset, length and file size we need to
        -: 1000:     * 
        -: 1001:     *      check if we are at beginning:
        -: 1002:     *              Load data a block from disk into a temporary buffer and copy from (offset%block_size) to the end : BEGINNING OF THE BUFFER.
        -: 1003:     *                      memset (  buf (start?)   , starting of block + offset,  FS_BLOCK_SIZE - offset );
        -: 1004:     *                      
        -: 1005:     *      check if we are at middle block(s)(!): - loop(?)
        -: 1006:     *              Load the complete blocks into the buffer
        -: 1007:     *                      memset (  buffer ,  full-blocks,    FS_BLOCK_SIZE )
        -: 1008:     *                      
        -: 1009:     *      check if we are at end blocks:
        -: 1010:     *              Load the last block into a temporary buffer and copy part of it to the buffer.
        -: 1011:     *                      memset (  buffer ,  starting of last block,     (till EOF) FS_BLOCK_SIZE - remaining(?) )
        -: 1012:     *
        -: 1013:     *
        -: 1014:     *
        -: 1015:     *      boils down to 
        -: 1016:     *          Do Something...for indexs
        -: 1017:     *          loop {
        -: 1018:     *
        -: 1019:     *                  Do Something.. again 
        -: 1020:     *                  To find TEMP offset and BytesToRead
        -: 1021:     *
        -: 1022:     *                  memset ( buf, TEMP + offset, BytesToRead)
        -: 1023:     *
        -: 1024:     *                  Do Something again to update values
        -: 1025:     * 
        -: 1026:     *          }
        -: 1027:     *
        -: 1028:     *          return;
        -: 1029:     */
     8827: 1030:static int fs_read(const char *path, char *buf, size_t len, off_t offset,
        -: 1031:  struct fuse_file_info *fi)
        -: 1032:{
        -: 1033:    int index;
        -: 1034:    int i;
        -: 1035:    int inum;
     8827: 1036:    int bytesToRead = (int) len;
     8827: 1037:    int bytes_Read = 0;
     8827: 1038:    int total = len;
        -: 1039:
     8827: 1040:    inum = translate(path);
        -: 1041:
     8827: 1042:    if (inum < 0) {
       11: 1043:        return -ENOENT;
     8816: 1044:    } else if (S_ISDIR(inodes[inum].mode)) {
        4: 1045:        return -EISDIR;
        -: 1046:    }
        -: 1047:
     8812: 1048:    int file_len = inodes[inum].size;
     8812: 1049:    if ( offset >= file_len ) {
       33: 1050:        if (file_len) printf("\n");
       33: 1051:        return 0;
        -: 1052:    }
     8779: 1053:    if (offset + len >= file_len) total = file_len - offset;
     8779: 1054:    int counter = 0;
        -: 1055:
    27586: 1056:    while (total > 0) {
    10028: 1057:        int blk_offset = offset/1024;
    10028: 1058:        int blk_number = logical2Physical(inum, blk_offset, 0);
        -: 1059:
    10028: 1060:        if (!blk_number) return -EINVAL;
        -: 1061:
    10028: 1062:        char *tempBuffer = (char*) malloc(FS_BLOCK_SIZE);
    10028: 1063:        bzero(tempBuffer, FS_BLOCK_SIZE);
        -: 1064:        
    10028: 1065:        if (disk->ops->read(disk, blk_number, 1, tempBuffer)) {
    #####: 1066:            exit(1);
        -: 1067:        }
        -: 1068:        
    10028: 1069:        bytesToRead = ( (blk_offset + 1) * FS_BLOCK_SIZE ) - offset;
    10028: 1070:        i = offset % FS_BLOCK_SIZE;
    10028: 1071:        if (bytesToRead > total) {
     8757: 1072:            bytesToRead = total;
        -: 1073:        }
        -: 1074:
        -: 1075:        // strncpy( buf , tempBuffer + i, bytesToRead);
    10028: 1076:        memcpy(buf + counter, tempBuffer + i, bytesToRead);
        -: 1077:
        -: 1078:        // buf += bytesToRead;
    10028: 1079:        counter += bytesToRead;
    10028: 1080:        offset += bytesToRead;
    10028: 1081:        total -= bytesToRead;
    10028: 1082:        free(tempBuffer);
        -: 1083:    }
        -: 1084:
     8779: 1085:    return counter;
        -: 1086:}
        -: 1087:
        -: 1088:/* write - write data to a file
        -: 1089: * It should return exactly the number of bytes requested, except on
        -: 1090: * error.
        -: 1091: * Errors - path resolution, ENOENT, EISDIR
        -: 1092: *  return EINVAL if 'offset' is greater than current file length.
        -: 1093: *  (POSIX semantics support the creation of files with "holes" in them,
        -: 1094: *   but we don't)
        -: 1095: */
     4528: 1096:static int fs_write(const char *path, const char *buf, size_t len,
        -: 1097: off_t offset, struct fuse_file_info *fi)
        -: 1098:{
        -: 1099:    int inum;
        -: 1100:    int blk;
        -: 1101:    int i;
        -: 1102:    int counter;
        -: 1103:
     4528: 1104:    int bytes_to_write = 0;
     4528: 1105:    int total = len;
     4528: 1106:    int iOffset = 0;
        -: 1107:
     4528: 1108:    inum = translate(path);
        -: 1109:    
     4528: 1110:    if (inum < 0) {
    #####: 1111:        return -ENOENT;
     4528: 1112:    } else if (S_ISDIR(inodes[inum].mode)) {
    #####: 1113:        return -EISDIR;
        -: 1114:    }
        -: 1115:
     4528: 1116:    if ( offset > inodes[inum].size ) {
    #####: 1117:        return -EINVAL;
        -: 1118:    }
     4528: 1119:    counter = 0;
        -: 1120:
    18339: 1121:    while (total) {
        -: 1122:
     9284: 1123:        int blk_offset = offset/FS_BLOCK_SIZE;
     9284: 1124:        blk = logical2Physical(inum, blk_offset, 1);
        -: 1125:
     9284: 1126:        if (blk == 0) return -EINVAL;
     9284: 1127:        if (blk < 0) return -ENOSPC;
        -: 1128:
     9283: 1129:        char *tempBuffer = malloc(FS_BLOCK_SIZE) ;
     9283: 1130:        if (disk->ops->read(disk, blk, 1, tempBuffer) < 0) {
    #####: 1131:            exit(1);
        -: 1132:        }
        -: 1133:
     9283: 1134:        bytes_to_write = ( (blk_offset + 1) * FS_BLOCK_SIZE ) - offset;
     9283: 1135:        i = offset % FS_BLOCK_SIZE;
     9283: 1136:        if (bytes_to_write > total) {
     3980: 1137:            bytes_to_write = total;
        -: 1138:        }
        -: 1139:        // memset(TEMP + iOffset, buf[offset] , bytes_to_write);
        -: 1140:        // strncpy(TEMP, buf + offset, bytes_to_write);
        -: 1141:        // for (i = iOffset; i < iOffset + bytes_to_write; ++i)
        -: 1142:        // {
        -: 1143:        //     tempBuffer[i] = buf[bytesWritten++];
        -: 1144:        // }
     9283: 1145:        memcpy(tempBuffer + i, buf + counter, bytes_to_write);
        -: 1146:
     9283: 1147:        if (disk->ops->write(disk, blk, 1, tempBuffer) < 0) {
    #####: 1148:            exit(1);
        -: 1149:        }
        -: 1150:
        -: 1151:        // bytesWritten+= bytes_to_write;
     9283: 1152:        offset += bytes_to_write;
     9283: 1153:        counter += bytes_to_write;
     9283: 1154:        total-= bytes_to_write;
     9283: 1155:        free(tempBuffer);
     9283: 1156:        writeEverythingtoDisk();
        -: 1157:    }
        -: 1158:
     4527: 1159:    inodes[inum].size += counter;
     4527: 1160:    writeEverythingtoDisk();
        -: 1161:
     4527: 1162:    return counter;
        -: 1163:    // return -EOPNOTSUPP;
        -: 1164:}
        -: 1165:
       54: 1166:static int fs_open(const char *path, struct fuse_file_info *fi)
        -: 1167:{
       54: 1168:    return 0;
        -: 1169:}
        -: 1170:
       54: 1171:static int fs_release(const char *path, struct fuse_file_info *fi)
        -: 1172:{
       54: 1173:    return 0;
        -: 1174:}
        -: 1175:
        1: 1176:static int blocksFree(struct fs_super sb)
        -: 1177:{
        1: 1178:    int result = 0;
        -: 1179:    int i;
     8193: 1180:    for (i = 0; i < sb.block_map_sz * 8192; i++)
     8192: 1181:        if (FD_ISSET(i, block_map)) {
      295: 1182:            result++;
        -: 1183:        }
        1: 1184:        return sb.num_blocks - result;
        -: 1185:    }
        -: 1186:
        -: 1187:
        -: 1188:/* statfs - get file system statistics
        -: 1189: * see 'man 2 statfs' for description of 'struct statvfs'.
        -: 1190: * Errors - none.
        -: 1191: */
        1: 1192:    static int fs_statfs(const char *path, struct statvfs *st)
        -: 1193:    {
        -: 1194:    /* needs to return the following fields (set others to zero):
        -: 1195:     *   f_bsize = BLOCK_SIZE
        -: 1196:     *   f_blocks = total image - metadata
        -: 1197:     *   f_bfree = f_blocks - blocks used
        -: 1198:     *   f_bavail = f_bfree
        -: 1199:     *   f_namelen = <whatever your max namelength is>
        -: 1200:     *
        -: 1201:     * this should work fine, but you may want to add code to
        -: 1202:     * calculate the correct values later.
        -: 1203:     */
        -: 1204:        struct fs_super sb;
        1: 1205:        if (disk->ops->read(disk, 0, 1, &sb) < 0)
    #####: 1206:            exit(1);
        -: 1207:
        1: 1208:        int numOfFreeBlocks = blocksFree(sb);
        1: 1209:        st->f_bsize = FS_BLOCK_SIZE;
        1: 1210:        st->f_blocks = sb.num_blocks;           /* probably want to */
        1: 1211:        st->f_bfree = numOfFreeBlocks;            /* change these */
        1: 1212:        st->f_bavail = numOfFreeBlocks;           /* values */
        1: 1213:        st->f_namemax = 27;
        -: 1214:
        1: 1215:        return 0;
        -: 1216:    }
        -: 1217:
        -: 1218:/* operations vector. Please don't rename it, as the skeleton code in
        -: 1219: * misc.c assumes it is named 'fs_ops'.
        -: 1220: */
        -: 1221:    struct fuse_operations fs_ops = {
        -: 1222:        .init = fs_init,
        -: 1223:        .getattr = fs_getattr,
        -: 1224:        .opendir = fs_opendir,
        -: 1225:        .readdir = fs_readdir,
        -: 1226:        .releasedir = fs_releasedir,
        -: 1227:        .mknod = fs_mknod,
        -: 1228:        .mkdir = fs_mkdir,
        -: 1229:        .unlink = fs_unlink,
        -: 1230:        .rmdir = fs_rmdir,
        -: 1231:        .rename = fs_rename,
        -: 1232:        .chmod = fs_chmod,
        -: 1233:        .utime = fs_utime,
        -: 1234:        .truncate = fs_truncate,
        -: 1235:        .open = fs_open,
        -: 1236:        .read = fs_read,
        -: 1237:        .write = fs_write,
        -: 1238:        .release = fs_release,
        -: 1239:        .statfs = fs_statfs,
        -: 1240:    };
